<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Collaborative Video Queue</title>
  <link rel="stylesheet" href="./style.css">
  <!---------------  Font Aewsome  --------------------->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" 
    integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
  <h1>Collaborative Video Queue</h1>

    <ul id="itemList" aria-label="Items list">
    <!-- items added by JS -->
    </ul>

  <button id="ytbutton" >
        <img src="./Images/icons/youtube_icon.png" width="60px">
    </button>
    <div id="ytPopup" class="ytpopup">
        <div class="ytpopup-content">

            <label><span>Search youtube videos</span></label><br><br>
          
              
            <div id="buttons">

                <label> <input id="query" value='' autocomplete="off" type="text"/><button id="search-button"  onclick="keyWordsearch()">Search</button></label>   
                <button onclick="searchSpotify()">search spotify</button> 
                <div id="container">
                <p>Search Results:</p>
                <ul id="results"></ul>
                </div>  

            </div>

        </div>
    </div>

  <!-- YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
      <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://apis.google.com/js/client.js?onload=googleApiClientReady">   </script>


<!---------------- firebase script ------------->
<script type="module">
import { 
    initializeApp 
} from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
import { 
    getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, deleteDoc, getDocs, limit, where, updateDoc
} from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

// Firebase config
const firebaseConfig = {
    apiKey: "AIzaSyBkfk1Uc7DnKAQoHV67RPgYX77wfqov-rA",
    authDomain: "my-static-firebase-demo.firebaseapp.com",
    projectId: "my-static-firebase-demo",
    storageBucket: "my-static-firebase-demo.firebasestorage.app",
    messagingSenderId: "809904428695",
    appId: "1:809904428695:web:3a8c65f6c2f448bcaa7bd2",
    measurementId: "G-0JRKKFR4LZ"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const videosCol = collection(db, "videos");
let queueDocs = [];

window.addToEnd = async function(name, videoId, platform) {
  try {
    // Get the video with the highest current order value
    const q = query(videosCol, orderBy("order", "desc"), limit(1));
    const querySnapshot = await getDocs(q);

    let maxOrder = 0;
    if (!querySnapshot.empty) {
      const topDoc = querySnapshot.docs[0];
      maxOrder = topDoc.data().order || 0;
    }

    // Add the new video to Firestore
    await addDoc(videosCol, {
      platform,
      name,
      url: "https://www.youtube.com/watch?v=" + videoId,
      order: maxOrder + 1,
      createdAt: serverTimestamp()
    });

    alert("✅ Video added to queue!");
  } catch (err) {
    console.error("Error adding video:", err);
    alert("❌ Error adding video: " + err.message);
  }
};

window.swapOrder = async function(orderA, orderB) {
  try {
    // Query for the two videos
    const qA = query(videosCol, where("order", "==", orderA));
    const qB = query(videosCol, where("order", "==", orderB));

    const [snapA, snapB] = await Promise.all([getDocs(qA), getDocs(qB)]);

    if (snapA.empty || snapB.empty) {
      alert("One or both videos not found!");
      return;
    }

    // Get document refs
    const docA = snapA.docs[0];
    const docB = snapB.docs[0];

    // Swap their order values
    await Promise.all([
      updateDoc(docA.ref, { order: orderB }),
      updateDoc(docB.ref, { order: orderA })
    ]);

    console.log(`Swapped order ${orderA} ↔ ${orderB}`);
    alert(`✅ Swapped videos ${orderA} and ${orderB}`);
  } catch (err) {
    console.error("Error swapping order:", err);
    alert("❌ Error swapping order: " + err.message);
  }
}

window.deleteByOrder = async function(orderValue) {
  try {
    // Query for the document with this order value
    const q = query(videosCol, where("order", "==", orderValue));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      alert(`⚠️ No video found with order ${orderValue}`);
      return;
    }

    // Usually there should be only one, but handle multiple just in case
    const deletions = querySnapshot.docs.map(docSnap => deleteDoc(docSnap.ref));
    await Promise.all(deletions);

    console.log(`Deleted video(s) with order ${orderValue}`);
    alert(`✅ Deleted video with order ${orderValue}`);
  } catch (err) {
    console.error("Error deleting video:", err);
    alert("❌ Error deleting video: " + err.message);
  }
}


window.swapWithSecondSmallest =  async function(orderValue) {
  try {
    // Get all videos ordered by "order" ascending
    const q = query(videosCol, orderBy("order", "asc"));
    const snapshot = await getDocs(q);

    if (snapshot.size < 2) {
      alert("⚠️ Not enough videos to perform a swap.");
      return;
    }

    // Extract documents and order values
    const docs = snapshot.docs;
    const secondSmallestDoc = docs[1];
    const secondSmallestOrder = secondSmallestDoc.data().order;

    // Check the target document
    const targetQuery = query(videosCol, where("order", "==", orderValue));
    const targetSnap = await getDocs(targetQuery);

    if (targetSnap.empty) {
      alert(`⚠️ No video found with order ${orderValue}`);
      return;
    }

    const targetDoc = targetSnap.docs[0];

    // Rule: only swap if orderValue > secondSmallestOrder
    if (orderValue <= secondSmallestOrder) {
      alert("⚠️ This video cannot be swapped (it's already one of the first two).");
      return;
    }

    // Swap orders
    await Promise.all([
      updateDoc(targetDoc.ref, { order: secondSmallestOrder }),
      updateDoc(secondSmallestDoc.ref, { order: orderValue })
    ]);

    console.log(`Swapped video with order ${orderValue} ↔ ${secondSmallestOrder}`);
    alert(`✅ Swapped order ${orderValue} ↔ ${secondSmallestOrder}`);
  } catch (err) {
    console.error("Error swapping orders:", err);
    alert("❌ Error swapping orders: " + err.message);
  }
}

    // Listen for the queue in real-time
    onSnapshot(query(videosCol, orderBy("order", "asc")), (snapshot) => {
      queueDocs = snapshot.docs;
      var objects_li = [];
      queueDocs.forEach((docItem, index) => {
        const data = docItem.data();
        objects_li.push(data);
      });
      addMany(objects_li);
    });

  </script>

<!--------------- youtube script --------------->
<script>
    
    ytbutton.addEventListener("click", function () {
        
        ytPopup.classList.add("show");
        
    });

    window.addEventListener('click', function () {
        if ((event.target == ytPopup)) {
            ytPopup.classList.remove("show");
            
        }
    });

    function keyWordsearch(){
        $('#results').append(
                    '<pre>' + "sercherd"+ '</pre>'
                    );  
        gapi.client.setApiKey('AIzaSyDFmmtvaShc4ADiWtDmQEl-UYwqH5ZiEvc');
        gapi.client.load('youtube', 'v3', function(){
                makeRequest();
        });
        $('#results').append(
                    '<pre>' + "got thru"+ '</pre>'
                    );  
    }

function makeRequest(){
        var q = $('#query').val();
        $('#results').append(
                    '<pre>' + q + '</pre>'
                    );  
        var request = gapi.client.youtube.search.list({
                q: q,
                part: "snippet", 
                maxResults: 10,
                videoEmbeddable: "true",
                type: "video"
        });

        $('#results').append(
                    '<pre>' + "request" + '</pre>'
                    );  
        request.execute(function(response) {
  $('#results').empty();
  const srchItems = response.result.items;

  srchItems.forEach(item => {
    const vidTitle = $('<pre>')
      .css({
        width: '100%',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word'
      })
      .text(item.snippet.title);

    const vidThumbimg = $('<img>')
      .attr({
        src: item.snippet.thumbnails.default.url,
        alt: 'No Image Available.'
      })
      .css({
        width: '204px',
        height: '128px'
      });

    // Create the button safely and attach a click event
    const vidButton = $('<a>')
      .attr('href', '#')
      .text('Add to Queue')
      .on('click', e => {
        e.preventDefault();
        addToEnd(item.snippet.title, item.id.videoId, 'youtube');
      });

    // Append to results container
    const container = $('<div>').css({ marginBottom: '1em' });
    container.append(vidTitle, $('<div>').append(vidThumbimg), $('<div>').append(vidButton));

    $('#results').append(container);
  });
});
}</script> 

<!---------------- spotify script --------------->
<script>
  
async function searchSpotify() {
  const q = $('#query').val();
  $('#results').append('<pre>' + q + '</pre>');

  try {
    const res = await fetch(`https://jasp202.netlify.app/.netlify/functions/spotify-search?q=${encodeURIComponent(q)}`);
    $('#results').append('<pre>' + res + '</pre>');
    const tracks = await res.json();
    $('#results').empty(); // clear previous results

    tracks.forEach(track => {
      const trackTitle = $('<pre>')
        .css({ width: '100%', whiteSpace: 'pre-wrap', wordWrap: 'break-word' })
        .text(track.name);

      const trackThumb = $('<img>')
        .attr({ src: track.image, alt: 'No Image Available.' })
        .css({ width: '64px', height: '64px' });

      const trackButton = $('<a>')
        .attr('href', '#')
        .text('Add to Queue')
        .on('click', e => {
          e.preventDefault();
          addToEnd(track.name, track.id, 'spotify');
        });

      const container = $('<div>').css({ marginBottom: '1em' });
      container.append(trackTitle, $('<div>').append(trackThumb), $('<div>').append(trackButton));

      $('#results').append(container);
    });
  } catch (err) {
    $('#results').append('<pre>Error loading Spotify results.</pre>');
  }
}

</script>

     <script src="script-sortable.js"></script>
</body>
</html>
