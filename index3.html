<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Collaborative Video Queue</title>
  <link rel="stylesheet" href="./style.css">
  <!---------------  Font Aewsome  --------------------->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" 
    integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
  <h1>Collaborative Video Queue</h1>

  <form id="video-form">
    <input type="url" id="video-url" placeholder="YouTube URL" required />
    <button type="submit">Add to Queue</button>
  </form>

  <h2>Now Playing:</h2>
  <div id="now-playing"></div>

  <h2>Queue:</h2>
  <ul id="video-list"></ul>
  
<div class="controls" role="region" aria-label="Add item">
  <input name="newItem" id="newItem" placeholder="New item text..." />
  <button id="addBtn" class="primary">Add</button>
  <button id="addSample">Add sample</button>
</div>

    <ul id="itemList" aria-label="Items list">
    <!-- items added by JS -->
    </ul>

  <button id="ytbutton" >
        <img src="./Images/icons/youtube_icon.png" width="60px">
    </button>
    <div id="ytPopup" class="ytpopup">
        <div class="ytpopup-content">

            <label><span>Search youtube videos</span></label><br><br>
            <label class="switch">
                <input id="checkyt" type="checkbox" value="car">
                <span class="slider round"></span>
              </label>
              <label for="checkyt"> Video player active</label><br><br>
              
            <div id="buttons">

                <label> <input id="query" value='' autocomplete="off" type="text"/><button id="search-button"  onclick="keyWordsearch()">Search</button></label>    
                <div id="container">
                <p>Search Results:</p>
                <ul id="results"></ul>
                </div>  

            </div>
            

        </div>
    </div>

  <!-- YouTube IFrame API -->
  <script src="https://www.youtube.com/iframe_api"></script>
      <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://apis.google.com/js/client.js?onload=googleApiClientReady">   </script>

  <script type="module">
    import { 
      initializeApp 
    } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
    import { 
      getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, deleteDoc, getDocs, limit, where, updateDoc
    } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyBkfk1Uc7DnKAQoHV67RPgYX77wfqov-rA",
      authDomain: "my-static-firebase-demo.firebaseapp.com",
      projectId: "my-static-firebase-demo",
      storageBucket: "my-static-firebase-demo.firebasestorage.app",
      messagingSenderId: "809904428695",
      appId: "1:809904428695:web:3a8c65f6c2f448bcaa7bd2",
      measurementId: "G-0JRKKFR4LZ"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const videosCol = collection(db, "videos");

    const nowPlayingDiv = document.getElementById("now-playing");
    const queueList = document.getElementById("video-list");

    let player = null;
    let currentVideoID = null;
    let queueDocs = [];

    window.addToEnd = async function(name, videoId, platform) {
  try {
    // Get the video with the highest current order value
    const q = query(videosCol, orderBy("order", "desc"), limit(1));
    const querySnapshot = await getDocs(q);

    let maxOrder = 0;
    if (!querySnapshot.empty) {
      const topDoc = querySnapshot.docs[0];
      maxOrder = topDoc.data().order || 0;
    }

    // Add the new video to Firestore
    await addDoc(videosCol, {
      platform,
      name,
      url: "https://www.youtube.com/watch?v=" + videoId,
      order: maxOrder + 1,
      createdAt: serverTimestamp()
    });

    alert("✅ Video added to queue!");
  } catch (err) {
    console.error("Error adding video:", err);
    alert("❌ Error adding video: " + err.message);
  }
};
window.swapOrder = async function(orderA, orderB) {
  try {
    // Query for the two videos
    const qA = query(videosCol, where("order", "==", orderA));
    const qB = query(videosCol, where("order", "==", orderB));

    const [snapA, snapB] = await Promise.all([getDocs(qA), getDocs(qB)]);

    if (snapA.empty || snapB.empty) {
      alert("One or both videos not found!");
      return;
    }

    // Get document refs
    const docA = snapA.docs[0];
    const docB = snapB.docs[0];

    // Swap their order values
    await Promise.all([
      updateDoc(docA.ref, { order: orderB }),
      updateDoc(docB.ref, { order: orderA })
    ]);

    console.log(`Swapped order ${orderA} ↔ ${orderB}`);
    alert(`✅ Swapped videos ${orderA} and ${orderB}`);
  } catch (err) {
    console.error("Error swapping order:", err);
    alert("❌ Error swapping order: " + err.message);
  }
}
window.deleteByOrder = async function(orderValue) {
  try {
    // Query for the document with this order value
    const q = query(videosCol, where("order", "==", orderValue));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      alert(`⚠️ No video found with order ${orderValue}`);
      return;
    }

    // Usually there should be only one, but handle multiple just in case
    const deletions = querySnapshot.docs.map(docSnap => deleteDoc(docSnap.ref));
    await Promise.all(deletions);

    console.log(`Deleted video(s) with order ${orderValue}`);
    alert(`✅ Deleted video with order ${orderValue}`);
  } catch (err) {
    console.error("Error deleting video:", err);
    alert("❌ Error deleting video: " + err.message);
  }
}
window.swapWithSecondSmallest =  async function(orderValue) {
  try {
    // Get all videos ordered by "order" ascending
    const q = query(videosCol, orderBy("order", "asc"));
    const snapshot = await getDocs(q);

    if (snapshot.size < 2) {
      alert("⚠️ Not enough videos to perform a swap.");
      return;
    }

    // Extract documents and order values
    const docs = snapshot.docs;
    const secondSmallestDoc = docs[1];
    const secondSmallestOrder = secondSmallestDoc.data().order;

    // Check the target document
    const targetQuery = query(videosCol, where("order", "==", orderValue));
    const targetSnap = await getDocs(targetQuery);

    if (targetSnap.empty) {
      alert(`⚠️ No video found with order ${orderValue}`);
      return;
    }

    const targetDoc = targetSnap.docs[0];

    // Rule: only swap if orderValue > secondSmallestOrder
    if (orderValue <= secondSmallestOrder) {
      alert("⚠️ This video cannot be swapped (it's already one of the first two).");
      return;
    }

    // Swap orders
    await Promise.all([
      updateDoc(targetDoc.ref, { order: secondSmallestOrder }),
      updateDoc(secondSmallestDoc.ref, { order: orderValue })
    ]);

    console.log(`Swapped video with order ${orderValue} ↔ ${secondSmallestOrder}`);
    alert(`✅ Swapped order ${orderValue} ↔ ${secondSmallestOrder}`);
  } catch (err) {
    console.error("Error swapping orders:", err);
    alert("❌ Error swapping orders: " + err.message);
  }
}

    // Extract video ID from YouTube URL
    function extractVideoID(url) {
      const regExp = /^.*((youtu.be\/)|(v\/)|(u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
      const match = url.match(regExp);
      return (match && match[7].length === 11) ? match[7] : null;
    }

    // Play a video in the player
    function playVideo(url) {
      const videoID = extractVideoID(url);
      if (!videoID) return;

      if (!player) {
        player = new YT.Player('now-playing', {
          height: '360',
          width: '640',
          videoId: videoID,
          events: {
            'onStateChange': onPlayerStateChange
          }
        });
      } else {
        player.loadVideoById(videoID);
      }
      currentVideoID = url;
    }

    // Handle video ended
    async function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.ENDED && queueDocs.length > 0) {
        // Remove the first video from Firestore
        const firstVideoDoc = queueDocs[0];
        await deleteDoc(doc(db, "videos", firstVideoDoc.id));
      }
    }

    // Listen for the queue in real-time
    onSnapshot(query(videosCol, orderBy("order", "asc")), (snapshot) => {
      queueDocs = snapshot.docs;

      // Play next video only if first video changes
      if (queueDocs.length > 0) {
        const firstVideo = queueDocs[0].data();
        if (firstVideo.url !== currentVideoID) {
          playVideo(firstVideo.url);
        }
      } else {
        currentVideoID = null;
        nowPlayingDiv.innerHTML = "<p>No videos in the queue</p>";
      }

      // Render queue list
      queueList.innerHTML = "";
      var objects_li = [];
      queueDocs.forEach((docItem, index) => {
        const li = document.createElement("li");
        const data = docItem.data();
        objects_li.push(data);
        li.textContent = data.url;

        const btn = document.createElement("button");
        btn.textContent = "Remove";
        btn.addEventListener("click", async () => {
          await deleteDoc(doc(db, "videos", docItem.id));
        });

        li.appendChild(btn);
        queueList.appendChild(li);
      });
      addMany(objects_li);
    });

    // Add video form
    document.getElementById("video-form").addEventListener("submit", async (e) => {
      e.preventDefault();
      const url = document.getElementById("video-url").value.trim();
      if (!url) return;

      await addDoc(videosCol, {
        url,
        createdAt: serverTimestamp()
      });
      e.target.reset();
    });

    window.addVideoToQueue = async function(videoId) {
  try {
    await addDoc(videosCol, {
      url: "https://www.youtube.com/watch?v=" + videoId,
      createdAt: serverTimestamp()
    });
    alert("Video added to queue!"); // optional for confirmation
  } catch (err) {
    alert("Error adding video:");
  }
};
  </script>

  

  <!---------------  YOUTUBE API DOWNLOAD --------------------->
<!---------------  jQuery  --------------------->


    

<script>
    
    ytbutton.addEventListener("click", function () {
        
        ytPopup.classList.add("show");
        
    });

    window.addEventListener('click', function () {
        if ((event.target == ytPopup)) {
            ytPopup.classList.remove("show");
            
        }
    });
    checkyt.addEventListener('change', (event) => {
        if (event.currentTarget.checked) {
            document.getElementById("video-background").style.display = "block"

        } else {
            document.getElementById("video-background").style.display = "none"
            document.getElementById("video-background").src = ""
            
        }})

    function keyWordsearch(){
        $('#results').append(
                    '<pre>' + "sercherd"+ '</pre>'
                    );  
        gapi.client.setApiKey('AIzaSyDFmmtvaShc4ADiWtDmQEl-UYwqH5ZiEvc');
        gapi.client.load('youtube', 'v3', function(){
                makeRequest();
        });
        $('#results').append(
                    '<pre>' + "got thru"+ '</pre>'
                    );  
    }

    function makeRequest(){
        
        var q = $('#query').val();
        $('#results').append(
                    '<pre>' + q + '</pre>'
                    );  
        var request = gapi.client.youtube.search.list({
                q: q,
                part: "snippet", 
                maxResults: 10,
                videoEmbeddable: "true",
                type: "video"
        });

        $('#results').append(
                    '<pre>' + "request" + '</pre>'
                    );  
        request.execute(function(response) {
  $('#results').empty();
  const srchItems = response.result.items;

  srchItems.forEach(item => {
    const vidTitle = $('<pre>')
      .css({
        width: '100%',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word'
      })
      .text(item.snippet.title);

    const vidThumbimg = $('<img>')
      .attr({
        src: item.snippet.thumbnails.default.url,
        alt: 'No Image Available.'
      })
      .css({
        width: '204px',
        height: '128px'
      });

    // Create the button safely and attach a click event
    const vidButton = $('<a>')
      .attr('href', '#')
      .text('Add to Queue')
      .on('click', e => {
        e.preventDefault();
        addToEnd(item.snippet.title, item.id.videoId, 'youtube');
      });

    // Append to results container
    const container = $('<div>').css({ marginBottom: '1em' });
    container.append(vidTitle, $('<div>').append(vidThumbimg), $('<div>').append(vidButton));

    $('#results').append(container);
  });
});
}
     // Function to update the video iframe's source
     function loadVideo(videoId) {
        document.getElementById("video-background").src = "https://www.youtube.com/embed/" + videoId + "?&autoplay=1&controls=1&loop=1";
        document.getElementById("ytPopup").classList.remove("show");
        document.getElementById("video-background").style.display = "block"
        document.getElementById('checkyt').checked = true
    }
     </script> 


     <script src="script-sortable.js"></script>
</body>
</html>
